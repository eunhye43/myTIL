#### 🪓 CQRS
* CQRS는 Command Query Responsibility Segregation 의 약자로 단어 그대로 해석하면 "명령 조회 책임 분리". **Command와 Query의 분리.** 이는 애플리케이션들을 구성하는 아키텍처에 대한 하나의 패턴이라고 함. 즉, 애플리케이션을 구현함에 있어 명령과 조회에 대한 책임을 분리하는 것이 CQRS.
* 일반적인으로 데이터를 연결된 데이터베이스에 레코드로써 생성(Create)하거나 조회(Read)하거나 갱신(Update)하거나 삭제(Delete). 장고 orm같이. 그리고 이렇게 데이터를 레코드로 저장하는 과정에서 데이터는 특정한 모델(Model)로써 다뤄짐. 이러한 모델은 초기 용도와는 다르게 다양한 레코드가 저장되어 조회/갱신/삭제 될 수 있다. 그러면 그 모델은 그대로 데이터에이스에 저장되겠지. 그럼 하나의 모델이 다양한 요구사항을 녹여내기 위해 거대해지거나 처음과는 다르게 변질 될 수 있음.
* 그렇기때문에 이런 모델을 재가공할 필요성이 있음. 모델이 변화함에 따라 실질적으로 데이터를 저장, 갱신, 삭제하는 모델과 조회해서 사용하는 모델 간 차이 발생. 그래서 개발자들은 하나의 데이터에 대해 저장, 갱신, 삭제하는 명령 부분과 조회해서 사용하는 조회 부분에 관한 모델을 분리하여 관리하게 된다. 이것이 CQRS가 등장하게 된 배경.
* CQRS 패턴은 다른 패턴들과 마찬가지로 어떠한 문제를 해결하는 하나의 방법. 그렇기 때문에 CQRS 패턴은 반드시 적용해야하는 패턴이 아닐 수도 있음. 아직 많은 애플리케이션은 CQRS를 적용하지 않는 CRUD 아키텍처가 적합. 게다가 CQRS 패턴은 쉽게 구현할 수 있는 패턴이 아니기에 불필요한 시스템 복잡도를 야기할 수 있음. 예를 들어, 모델의 적절한 경계를 구분하기 위해 DDD 방법론이 기반된 도메인 모델링이 필요할 수 있는 것 처럼.
---
![](https://images.velog.io/images/majaeh43/post/1b69c300-8c45-4288-a879-643af86c478e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-11-03%20%EC%98%A4%ED%9B%84%205.21.47.png)

---
* 최종적으로 명령과 조회에 대한 책임이 별도의 애플리케이션으로 완벽히 분리된 형태로 구현될 수 있음.



참고: https://always-kimkim.tistory.com/entry/cqrs-pattern
