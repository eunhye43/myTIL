🕶 <모두의 네트워크>를 읽고 학습한 내용을 정리한 포스트입니다! 화이팅! 🕶
## 6. 전송 계층: 신뢰할 수 있는 데이터 전송하기
23) 전송계층의 역할
✍️ 전송계층의 두 가지 역할
* 네트워크 계층에서 다른 네트워크로 데이터를 전송할 때, 라우터가 필요하고 그 라우터의 라우팅 기능 사용해서 데이터 전송가능하다고 공부함!
![](https://images.velog.io/images/majaeh43/post/7ae799a2-6db8-4b10-9ee4-b63155fe5a59/image.png)
> * **😨 근데 라우터의 라우팅 기능을 통해 데이터 전송했는데 목적지에 도착 못한다면????**
> * 물리계층, 데이터 링크 계층, 네트워크 계층의 3계층이 있으면 목적지에 데이터 보낼 수 있음 ! 근데 데이터가 손상되거나 유실되더라도 얘네들은 아무것도 해줄 수가 없어....ㅠㅠ
> * 근데 전송계층은 목적지에 신뢰할 수 있는 데이터를 전달할 수 있다~~~~~~👏
* 전송 계층에는 **오류를 점검하는 기능**이 있음! 오류가 발생하면 데이터를 재전송하도록 요청! 네트워크 계층은 목적지까지 데이터를 전달하고 전송계층에서는 데이터가 제대로 도착했는지 확인!
* 여기에! 컴터가 데이터를 받아도 어떤 앱에 전달해야하는지 모르면 곤란해. 그래서 **전송 계층에서는 전송된 데이터와 목적지가 어떤 앱인지 식별하는 기능도 있음.**

✍️ 연결형 통신과 비연결형 통신
* 전송 계층: 신뢰성/정확성, 효율성
* 연결형 통신: 신뢰할 수 있고 정확한 데이터를 전달하는 통신(신뢰성/정확성이 우선, 서로 여러 번 확인하고 보냄)
* 비연결형 통신: 효율적으로 데이터를 전달하는 통신(효율성이 우선, 일방적으로 보냄, ex. 동영상)
![](https://images.velog.io/images/majaeh43/post/24ce1498-6e2c-4442-852d-6c3cd6bba400/image.png)
* 연결형 통신 프로토콜에는 **TCP**가 사용되고, 비연결형 통신 프로토콜에는 **UDP**가 사용!

24) TCP의 구조
✍️ TCP란? 전송계층에서 신뢰할 수 있는 정확한 통신을 제공하는 프로토콜
* 데이터 링크 계층에서 이더넷 헤더를 붙여 **프레임**을 만들고 네트워크 계층에서 IP 헤더를 붙여 IP **패킷**을 만든 것처럼 전송 계층에서도 TCP 헤더를 붙여 **세그먼트**(Segment)를 만드는 캡슐화를 진행!
![](https://images.velog.io/images/majaeh43/post/b3a9e301-2cc9-4396-a25a-866ef539cd31/image.png)
* TCP는 **연결형 통신**에 사용. 연결형 통신은 꼼꼼하게 상대방을 확인하면서 데이터를 전송해야 하는데 그 전에 해야할 일은 **연결(Connection)**이라는 가상의 독점 통신로를 확보해야 한다. 
* 위 그림에서 **코드비트(6비트)**에 연결의 제어정보가 기록됨!
* 코트비트는 각 비트별로 역할이 있음. 초깃값은 0이고 비트가 활성화되면 1이 됨. 이 연결을 확립하려면 이중 SYN와 ACX가 필요.
* SYN은 **연결요청**, ACK는 **확인응답**.

✍️ 3-way 핸드셰이크란?
> * 연결은 SYN과 ACK를 사용해 확립할 수 있음. 신뢰할 수 있는 연결을 하려면 데이터를 전송하기 전에 패킷을 교환하는데 3번 함!
![](https://images.velog.io/images/majaeh43/post/92d4ffe0-dfff-4056-859c-c795d302fbd2/image.png)
* 이때, 연결 확립을 위해 코드 비트의 SYN과 ACK가 1로 활성화 됨.
(1) 통신을 하려면 컴퓨터2에게 허가를 받아야 하므로, 컴퓨터1에서 연결 확립 허가를 받기 위한 요청(SYN)를 보낸다.
(2) 컴퓨터2는 컴퓨터1이 보낸 요청을 받은 후에 허가한다는 응답을 회신하기 위해 연결 확립 응답(ACK)를 보내고 동시에 컴퓨터1에게 데이터 전송 허가를 받기 위해 연결 확립 요청(SYN)를 보낸다.
(3) 컴퓨터2의 요청을 받은 컴퓨터1은 컴퓨터2로 허가한다는 응답으로 연결 확립 응답(ACK)을 보낸다.
* 이처럼 데이터를 보내기 전에 연결을 확립하기 위해 패킷 요청을 **세 번 교환하는 것을 3-way 핸드세이크**라고 함 !

> * 데이터를 다 전송한 후에는 연결을 끊기위한 요청을 교환해야함 !
* 연결을 끊을 때는, FIN과 ACK를 사용하는데, FIN은 연결 종료를 뜻함. 이처럼 연결을 종료하기 위해 패킷 요청을 네 번 교환하는 것을 **4-way 핸드 셰이크(four-way handshake)**라고 한다.
![](https://images.velog.io/images/majaeh43/post/b35d08f0-2a84-4a2f-ab49-2dfad6fd7d49/image.png)
(1) 컴퓨터 1에서 컴퓨터 2로 연결 종료 요청(FIN)을 보낸다.
(2) 컴퓨터2에서 컴퓨터 1로 연결 종료 응답(ACK)을 반환한다.
(3) 또한 컴퓨터 2에서도 컴퓨터 1로 연결 종료 요청(FIN)을 보낸다.
> (4) 컴퓨터 1에서 컴퓨터 2로 연결 종료 응답(ACK)을 반환한다.

25) 일련번호와 확인 응답 번호의 구조
✍️ 일련번호와 확인 응답 번호란?
![](https://images.velog.io/images/majaeh43/post/b3a9e301-2cc9-4396-a25a-866ef539cd31/image.png)
* 요기에 **일련번호**와 **확인응답 번호**를 봐보자. 3-way 핸드셰이크가 끝나고 실제 데이터를 보내거나 상대방이 받을 때는 TCP 헤더의 일련번호와 확인응답 번호를 사용함!
* **일련번호**: 송신 측에서 수신 측에 '이 데이터가 몇 번째 데이터인지' 알려주는 역할. 전송된 데이터에 일련번호를 부여하면 수신자는 **원래 데이터의 몇 번째 데이터를 받았는지 알 수 있음.**
* **확인응답번호**: 수신 측이 '몇 번째 데이터'를 수신했는지 송신 측에 알려주는 역할. 예를 들어, 10번 데이터를 수신하면, 11번 데이터를 송신 측에 요청하는 것!

![](https://images.velog.io/images/majaeh43/post/8dedf3dc-a664-4acb-ac00-a2b956927a9a/image.png)
(1) 컴퓨터 1은 컴퓨터 2로 200바이트의 데이터를 전송한다.
(2) 컴퓨터 2는 200바이트를 수신하고 다음에 수신하고자 하는 데이터 번화를 확인 응답 번호에 넣는다. 다음에 수신하고자 하는 데이터는 3001+200=3201이므로 3201번부터 보내 달라고 요청한다.
(3) 컴퓨터 1은 컴퓨터 2로 3201번부터 200바이트의 데이터를 전송한다. 
(4) 컴퓨터 2는 200바이트를 수신하고 다음에 수신하고자 하는 데이터의 번호를 확인 응답 번호에 넣는다. 다음에 수신하고자 하는 데이터는 3201+200=3401번부터 보내 달라고 요청한다.

* 이렇게 (1)~(4)를 데이터 전송이 완료될 때까지 반복! 그치만 데이터가 항상 올바르게 전달되는 것은 아니므로 중간에 데이터가 손상되거나 유실된 경우에 데이터를 재전송하게 되어 있음! 그걸 **재전송 제어**라고 함!

2) 윈도우 크기란?
* 위에서 설명한 과정은 세그먼트(데이터) 하나를 보낼때마다 확인 응답을 한 번 반환하는 통신이라서 비효율적! 위 방식 대신에 매번 확인 응답을 기다리는 대신 세그먼트 연속해서 보내고 난 다음에 확인 응답을 반환하면 효율이 높아짐!
* 수신 측에서 받은 세그먼트를 일시적으로 보관하는 장소가 있는데 그 장소를 **버퍼(Buffer)**라고 함. 이 버퍼 덕분에 세그먼트를 연속해서 보내도 수신 측은 대응할 수 있고 확인 응답의 효율도 높아짐. 하지만, 세그먼트를 대량으로 받아 버퍼가 처리하지 못하는 경우가 생기는데 이 현상을 **오버플로(Over flow)**라고 함!
* 그래서** 버퍼의 한계크기**를 알고 있는게 중요해! (얼마나 많은 용량의 데이터를 저장해 둘 수 있는지!) 🌱 그게 TCP헤더의 **윈도우 크기** 값에 해당하는 것!
![](https://images.velog.io/images/majaeh43/post/dec37280-e7c2-462c-bc2f-c3532fe9d7d7/image.png)
* 이 윈도우 크기의 초깃값은 3-way 핸드세이크를 할 때 판단.

26) 포트 번호의 구조
✍️ 포트 번호란? 데이터의 목적지가 어떤 프로그램인지 구분하는 역할
* TCP의 또다른 역할 중 하나가, **전송된 데이터의 목적지가 어떤 앱인지 구분하는 역할** ! 이를 위해 **출발지 포트번호**와 **목적지 포트번호**가 필요해!
![](https://images.velog.io/images/majaeh43/post/33ca31ae-d691-4bf8-a8d7-7391d1c24e1e/image.png)
* 이 TCP 헤더에 포트번호가 있어서 앱을 구분할 수 있는 것!
* 포트번호는 0~65535번 사용할 수 있음!
* 0~1023번은 주요 프로토콜이 사용되도록 예약되어 있으며 잘 알려진 포트(Well-known ports)라고 함. 1024번은 예약되어 있지만 사용되지 않는 포트이고, 1025번 이상은 랜덤 포트라고 해서 클라이언트 측의 송신 포트로 사용됨.
![](https://images.velog.io/images/majaeh43/post/dc886e45-261e-4739-8d8f-615fbbba8538/image.png)
* 이처럼 동작하는 앱은 각각 포트번호가 있어서 다른 앱과 서로 구분됨. 데이터를 전송할 때는 상대방의 IP 주소가 필요하지만, 어떤 앱이 사용되고 있는지 구분하려면 TCP는 포트 번호가 필요해...🌱 

27) UDP의 구조
✍️ 전송계층에서 효율적으로 통신할 수 있도록 돕는 프로토콜
1) UDP란?
* 비연결형 통신이라서 데이터를 전송할 때 TCP처럼 시간이 걸리는 확인 작업을 일일이 하지 않음! 왜냐면 얘는 효율성을 중시하니까!
* UDP의 장점은 **데이터를 효율적으로 빠르게 보내는 것**이라서 스트리밍 방식으로 전송하는 동영상 서비스와 같은 곳에 사용됨!
2) UDP 헤더란?
* UDP 헤더가 붙은 데이터를 UDP 데이터그램이라고 함.
![](https://images.velog.io/images/majaeh43/post/7c592b0d-13c7-4a5c-a8ee-8fa42b1bcbaa/image.png)
* UDP를 사용하면 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낼 수 있음. 이것을 **브로드캐스트(Broadcast)**라고 하는데 브로드캐스트는 목적지에 관계없이 랜에서 일괄적으로 통보를 보낼 수 있어 가능. TCP는 3-way 핸드셰이크와 같이 데이터를 전송할 때도 확인 응답을 하나씩 보내야 하기 때문에 브로드캐스트와 같이 불특정 다수에게 보내는 통신은 적합하지 않을 뿐더러 **목적지를 지정하지 않으면 안 되기 때문에** 일괄 통신을 할 수 없다.
* TCP와 UDP의 비교
![](https://images.velog.io/images/majaeh43/post/4ebce5a9-5a00-4653-af6d-b985ba736b9a/image.png)

출처: https://almotjalal.tistory.com/102?category=961085
